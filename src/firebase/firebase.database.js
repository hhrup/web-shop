import { app } from './firebase.config';
import { getFirestore, collection, getDocs, addDoc, doc, deleteDoc, updateDoc, setDoc } from 'firebase/firestore';
import { getStorage, ref, uploadBytes, getDownloadURL, updateMetadata, listAll } from 'firebase/storage';
import { fromBlob } from 'image-resize-compress';

const db = getFirestore(app);

/*
FIREBASE FIRESTORE DATABASE STRUCTURE:

NAMING:
ROOT COLLECTION: productCategory
DOCUMENTS IN ROOT COLLECTION: category (example category name: cpu, gpu, mbo)
NAME OF THE COLLECTION IN category DOCUMENTS: product
NAME OF THE DOCUMENTS IN product COLLECTION: name is random ID generated by firebase

db SCHEMA:
productCategory => category => product => EfzEQpSx07yToau6AMyM => {name, price, description, imgUrl}

PRODUCT OBJECT PROPERTIES {name: string, price: number, description: string, imgUrl: string}

HOW IT WORKS WITH STORAGE:
  if (there is no image with the same name in storage)
    Image is uploaded to FIREBASE STORAGE, it returns an url that we store in product object, which is then sent to FIREBASE FIRESTORE
  else
    Gets url of already existing image, then the rest is the same as above
*/

// Get an array of documents(categories), optional: get documents(products) from product collection that each category has
export async function getCategoriesOrProducts(category) {
  if (!category) return [];

  const pathToProductCollection = category === 'productCategories' ? '' : `${category}/product`;
  const catsOrProdCollection = collection(db, `productCategory/${pathToProductCollection}`);

  let catOrProdSnapshot;
  try {
    catOrProdSnapshot = await getDocs(catsOrProdCollection);
  } catch (error) {
    console.error(error);
  }

  const productsList = category === 'productCategories' ? 
    catOrProdSnapshot.docs.map((doc) => doc.id)
    :
    (catOrProdSnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    })));

  return productsList;
}

export async function uploadProduct(file, product, isProductUpdate, productId, existingImgUrl) {
  try {
    let imgUrl;
    // doesImgExists = function: if img already exists in storage return URL without uploading the image, else upload the img
    if(!existingImgUrl){
      const doesImgExists = await checkForImgWithTheSameNameInStorage(file.name);
      if (!doesImgExists) {
        imgUrl = await uploadImageAndGetUrl(file);
      } else {
        imgUrl = doesImgExists;
      }
    } else {
      imgUrl = existingImgUrl;
    }

    product.imgUrl = imgUrl;

    if (isProductUpdate) {
      await updateProduct(product, productId);
    } else {
      await addProductToCategory(product);
    }
  } catch (error) {
    console.error(error);
  }
}

// main function used for adding products and categories. Categories are documents with collection product
async function addProductToCategory(product) {
  try {
    // First create a category document(setDoc) with a field inside it, so it 'exists' and we can read it (it's a Firebase "feature")
    await setDoc(doc(db, `productCategory/${product.category}`), {documentExists: true});
    await addDoc(collection(db, `productCategory/${product.category}`, 'product'), product);
  } catch (error) {
    console.error(error);
  }
}

async function updateProduct(product, productId) {
  try {
    const productRef = doc(db, `productCategory/${product.category}/product`, `${productId}`);
    await updateDoc(productRef, product);
  } catch (error) {
    console.error(error);
  }
}

export async function deleteDocument(documentId, productCat) {
  try {
    await deleteDoc(doc(db, `productCategory/${productCat}/product`, `${documentId}`));
  } catch (e) {
    console.error('Error deleting document: ', e);
  }
}

/////////////////////////////////////////////////
// FIREBASE CLOUD STORAGE(it's for images)///////
/////////////////////////////////////////////////
const storage = getStorage(app);

// Points to the root reference
const storageRef = ref(storage);

// reference(path) to a folder 'images' in cloud storage
const imagesRef = ref(storageRef, 'images'); 

async function uploadImageAndGetUrl(file) {
  if (!file) {
    alert('select an image to upload');
    return;
  }
  const imgName = file.name;
  const imgRef = ref(imagesRef, imgName);

 // resizing and compression logic here, after we check for an existing image in uploadProduct
  const quality = 80; // quality value for webp and jpeg formats.
  const width = 800; // output width. 0 will keep its original width and 'auto' will calculate its scale from height.
  const height = 'auto'; // output height. 0 will keep its original height and 'auto' will calculate its scale from width.
  const format = 'webp'; // file format: png, jpeg, bmp, gif, webp. If null, original format will be used.

  try {
    const resizedFile = await fromBlob(file, quality, width, height, format);
    resizedFile.name = file.name;

    const uploadedImage = await uploadBytes(imgRef, resizedFile);
    const fullPath = uploadedImage.ref.fullPath;

    const newMetadata = {
      cacheControl: 'public, max-age=31536000',
    }

    await updateMetadata(imgRef, newMetadata)

    const url = await getDownloadURL(ref(storage, fullPath));
    return url;
  } catch (error) {
    console.error(error);
  }
}

async function checkForImgWithTheSameNameInStorage(imgName) {
  try {
    const images = await listAll(imagesRef);
    const imgArr = images.items.filter(item => item.name === imgName);
    if (imgArr.length === 0) return false;

    const url = await getDownloadURL(ref(storage, imgArr[0].fullPath));
    return url;
  } catch (error) {
    console.error(error);
  }
}
