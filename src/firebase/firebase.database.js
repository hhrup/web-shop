import { app } from './firebase.config';
import { getFirestore, collection, getDocs, setDoc, addDoc, doc, deleteDoc } from 'firebase/firestore';
import { getStorage, ref, uploadBytes, getDownloadURL, updateMetadata, getMetadata } from 'firebase/storage';

const db = getFirestore(app);

/*
FIREBASE FIRESTORE DATABASE STRUCTURE:

NAMING:
ROOT COLLECTION: productCategory
DOCUMENTS IN ROOT COLLECTION: category (example category name: cpu, gpu, mbo)
NAME OF THE COLLECTION IN category DOCUMENTS: product
NAME OF THE DOCUMENTS IN product COLLECTION: name is random ID generated by firebase

CHART:
productCategory => category => product => EfzEQpSx07yToau6AMyM => {name, price, description, imgUrl}

PRODUCT OBJECT PROPERTIES {name: string, price: number, description: string, imgUrl: string}

HOW IT WORKS WITH STORAGE:
  Image is uploaded to FIREBASE STORAGE, it returns an url that we store in product object, which is then sent to FIREBASE FIRESTORE
*/

// Get an array of documents(categories), optional: get documents(products) from product collection that each category has
export async function getCategoriesOrProducts(category) {
  const pathToCollectionProduct = category ? `${category}/product` : '';
  const categoryOrproductsCol = collection(db, `productCategory/${pathToCollectionProduct}`);
  const catOrProdSnapshot = await getDocs(categoryOrproductsCol);

  const productsList = category ? 
    catOrProdSnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }))
    :
    catOrProdSnapshot.docs.map((doc) => doc.id);
  return productsList;
}

getCategoriesOrProducts();

// function addCategoryToProductCategory is probably not going to be used
export async function addCategoryToProductCategory(category) {
  if (!category) return;
  try {
    const productCategoryRef = doc(db, 'productCategory', category);
    await setDoc(
      productCategoryRef,
      { /* we are just adding a category, nothing else */ },
      { merge: true } // merge set to true so that we don't overwrite a category if method called twice
    );
  } catch (e) {
    console.error('Error adding document: ', e);
  }
}

export async function uploadProduct(file, product) {
  try {
    const imgUrl = await uploadImageAndGetUrl(file);

    product.imgUrl = imgUrl;

    await addProductToCategory(product);
  } catch (error) {
    console.error(error);
  }
}

// main function used for adding products and categories. Categories are documents with collection product
export async function addProductToCategory(product) {
  try {
    // it will implicitly create product collection
    const docRef = await addDoc(collection(db, `productCategory/${product.category}`, 'product'), product); 
    console.log('Product written with ID: ', docRef.id);
  } catch (error) {
    console.error(error);
  }
}

export async function deleteDocument() {
  try {
    await deleteDoc(doc(db, 'products', 'TyrU98sU8a4yboU0q9dE'));
  } catch (e) {
    console.error('Error deleting document: ', e);
  }
}
/////////////////////////////////////////////////
// FIREBASE CLOUD STORAGE(it's for images)///////
/////////////////////////////////////////////////

export const storage = getStorage(app);

// Points to the root reference
export const storageRef = ref(storage);

export async function uploadImageAndGetUrl(file) {
  if (!file) {
    alert('select an image to upload');
    return;
  }
  const imgName = file.name; // to be put into image name
  const imagesRef = ref(storageRef, 'images'); // reference(path) to a folder 'images' in cloud storage
  const imgRef = ref(imagesRef, imgName);

  try {
    const uploadedImage = await uploadBytes(imgRef, file);
    const fullPath = uploadedImage.ref.fullPath;
    const newMetadata = {
      cacheControl: 'public, max-age=31536000',
    }
  
    await updateMetadata(imgRef, newMetadata)

    const url = await getDownloadURL(ref(storage, fullPath));
    return url;
  } catch (error) {
    console.error(error);
  }
}


// 1.upload image  2.upload metadata  3.getUrl for object that will be sent to firebase database

export const uploadImage = async function(inputRef) {
  if (!inputRef.files[0]) {
    alert('select an image to upload');
    return;
  }
  console.log(inputRef.files[0]);
  const file = inputRef.files[0];
  const fileName = file.name; // to be put into image name
  console.log('file name: ', fileName);
  const imagesRef = ref(storageRef, 'images'); // reference(path) to an folder: images
  const imgRef = ref(imagesRef, 'image01'); // image01 = image name
  try {
    const uploadedImage = await uploadBytes(imgRef, file);
    console.log('Uploaded image: ', uploadedImage);
    console.log('Image full path: ', uploadedImage.ref.fullPath);
  } catch (error) {
    console.error(error);
  }
}

export const uploadMetadata = async function() {
  const newMetadata = {
    cacheControl: 'public, max-age=31536000',
  }
  const imagesRef = ref(storageRef, 'images'); // reference(path) to an folder: images
  const imgRef = ref(imagesRef, 'image01'); // image01 = image name
  try {
    const meta = await updateMetadata(imgRef, newMetadata)
    console.log('Update META: ', meta);
  } catch (error) {
    console.error(error);
  }
}

export const getImage = async function() {
  try {
    const url = await getDownloadURL(ref(storage, 'images/image01'));
    window.localStorage.setItem('imgUrl', JSON.stringify(url));
    this.setState({imgUrl: url});
  } catch (error) {
    console.error(error);
  }
}

export const downloadMetadata = async function() {
  const imagesRef = ref(storageRef, 'images'); // reference(path) to an folder: images
  const imgRef = ref(imagesRef, 'image01'); // image01 = image name
  try {
    const meta = await getMetadata(imgRef)
    console.log('META: ', meta);
  } catch (error) {
    console.error(error);
  }
}